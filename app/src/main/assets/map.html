<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>OSRS World Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
    <style>
        html, body { height: 100%; margin: 0; padding: 0; }
        #map { width: 100%; height: 100%; background-color: #0b0b0b; }

        /*
         * Apply nearest-neighbor interpolation to map tiles when they are upscaled
         * by the browser (i.e., for zoom levels > maxNativeZoom). This preserves
         * the sharp, pixelated aesthetic of the original game graphics.
         */
        .pixelated-overzoom .leaflet-tile {
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges; /* Firefox */
            image-rendering: crisp-edges;
        }
    </style>
</head>
<body>
<div id="map"></div>
<script>
    var map;

    function initializeMap(tileBaseUrl) {
        console.log("Initializing map with base URL: " + tileBaseUrl);

        const conversionFactor = 256.0;
        const contentWidth = 12800;
        const contentHeight = 45568;

        const boundsY = contentHeight / conversionFactor;
        const boundsX = contentWidth / conversionFactor;
        const contentMaxBounds = [[0, 0], [boundsY, boundsX]];

        const TopDownCRS = L.Util.extend({}, L.CRS.Simple, {
            transformation: new L.Transformation(1, 0, 1, 0)
        });

        const minZoom = 3;
        const maxZoom = 11;
        const maxNativeZoom = 8;
        const isRetina = L.Browser.retina;

        map = L.map('map', {
            crs: TopDownCRS,
            minZoom: minZoom,
            maxZoom: maxZoom,
            maxBounds: contentMaxBounds
        });
        
        // --- Layer Configuration ---

        // This is the base layer for standard-resolution tiles and overzooming.
        const standardLayer = L.tileLayer(tileBaseUrl + '{z}/{x}/{y}.png', {
            attribution: 'OSRS Wiki',
            tms: false,
            noWrap: true,
            bounds: [[0, 0], [256, 256]],
            maxNativeZoom: maxNativeZoom
        });

        var sharpRetinaLayer;

        if (isRetina) {
            // On retina devices, create a second layer that points to the @2x tiles.
            // No custom class is needed; sharpness is achieved by loading 512px
            // source images into a layer with a default 256px tile size.
            sharpRetinaLayer = new L.tileLayer(tileBaseUrl + '{z}/{x}/{y}@2x.png', {
                attribution: 'OSRS Wiki',
                tms: false,
                noWrap: true,
                bounds: [[0, 0], [256, 256]],
                maxZoom: maxNativeZoom - 1
            });
        }

        // --- Event Handling and Layer Management ---

        function updateLayerVisibility() {
            // This function is only relevant on retina devices.
            if (!sharpRetinaLayer) return;

            const currentZoom = map.getZoom();
            if (currentZoom < maxNativeZoom) {
                sharpRetinaLayer.setOpacity(1);
                standardLayer.setOpacity(0);
            } else {
                sharpRetinaLayer.setOpacity(0);
                standardLayer.setOpacity(1);
            }
        }

        function updatePixelation() {
            const currentZoom = map.getZoom();
            const container = standardLayer.getContainer();
            if (!container) return;

            if (currentZoom > maxNativeZoom) {
                L.DomUtil.addClass(container, 'pixelated-overzoom');
            } else {
                L.DomUtil.removeClass(container, 'pixelated-overzoom');
            }
        }
        
        function onZoomEnd() {
            updateLayerVisibility();
            updatePixelation();
        }

        // --- Map Initialization ---

        if (isRetina) {
            map.addLayer(standardLayer);
            map.addLayer(sharpRetinaLayer);
        } else {
            standardLayer.addTo(map);
        }
        
        map.on('zoomend', onZoomEnd);
        
        // Set initial state for all dynamic elements.
        onZoomEnd();
        
        map.setView([boundsY / 2, boundsX / 2], minZoom);
    }

    function loadPois(jsonData) {
        if (!map) {
            console.error("Map is not initialized. Cannot load POIs.");
            return;
        }
        try {
            const MIN_X_OFFSET = 1024;
            const MAX_Y_OFFSET = 12608;
            const PIXELS_PER_TILE = 4;
            const conversionFactor = 256.0;

            const pois = JSON.parse(jsonData);
            const markers = L.markerClusterGroup();

            pois.forEach(poi => {
                if (poi.plane === 0) {
                    let x_image = (poi.x - MIN_X_OFFSET) * PIXELS_PER_TILE;
                    let y_image = (MAX_Y_OFFSET - poi.y) * PIXELS_PER_TILE;
                    x_image += PIXELS_PER_TILE;
                    y_image -= PIXELS_PER_TILE;
                    const x_leaflet = x_image / conversionFactor;
                    const y_leaflet = y_image / conversionFactor;

                    const marker = L.marker([y_leaflet, x_leaflet]);
                    marker.bindPopup(`<b>${poi.name}</b><br>Game: [${poi.y}, ${poi.x}]`);
                    markers.addLayer(marker);
                }
            });
            map.addLayer(markers);
            console.log("Marker cluster layer added with final calibration.");
        } catch (e) {
            console.error("ERROR in loadPois(): ", e);
        }
    }
</script>
</body>
</html>
