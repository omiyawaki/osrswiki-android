<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>OSRS World Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
    <style>
        :root {
            --color-surface-variant: #444;
            --color-on-surface-variant: #ccc;
        }
        html, body { height: 100%; margin: 0; padding: 0; }
        #map { width: 100%; height: 100%; background-color: #0b0b0b; }
        .pixelated-zoom .leaflet-tile {
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        .leaflet-bar a,
        .leaflet-bar a:focus {
            background-color: var(--color-surface-variant) !important;
            color: var(--color-on-surface-variant) !important;
            border: none;
            outline: none;
        }
        .leaflet-bar a:active {
            background-color: var(--color-on-surface-variant) !important;
            color: var(--color-surface-variant) !important;
        }
        @media (hover: hover) and (pointer: fine) {
            .leaflet-bar a:hover {
                background-color: var(--color-on-surface-variant) !important;
                color: var(--color-surface-variant) !important;
            }
        }
        .leaflet-control-attribution {
            background-color: var(--color-surface-variant) !important;
            color: var(--color-on-surface-variant);
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <script>
        var map;
        const tileLayers = {};
        const poiLayers = {};
        var currentFloor = 0;

        const minZoom = 3;
        const maxZoom = 11;
        const maxNativeZoom = 8;
        const numFloors = 4;
        const isRetina = L.Browser.retina;

        function applyTheme() {
            if (typeof Android === 'undefined' || typeof Android.getThemeColors === 'undefined') return;
            try {
                const colorsJson = Android.getThemeColors();
                const colors = JSON.parse(colorsJson);
                if (colors.surfaceVariant && colors.onSurfaceVariant) {
                    document.documentElement.style.setProperty('--color-surface-variant', colors.surfaceVariant);
                    document.documentElement.style.setProperty('--color-on-surface-variant', colors.onSurfaceVariant);
                }
            } catch (e) { console.error("Error applying theme", e); }
        }

        function initializeMap(tileBaseUrl) {
            console.log("Initializing map with base URL: " + tileBaseUrl);
            const conversionFactor = 256.0;
            const contentMaxBounds = [[0, 0], [45568 / conversionFactor, 12800 / conversionFactor]];
            const TopDownCRS = L.Util.extend({}, L.CRS.Simple, {
                transformation: new L.Transformation(1, 0, 1, 0)
            });

            map = L.map('map', { crs: TopDownCRS, minZoom: minZoom, maxZoom: maxZoom, maxBounds: contentMaxBounds });

            for (let floor = 0; floor < numFloors; floor++) {
                const retinaUrl = tileBaseUrl + floor + '/{z}/{x}/{y}@2x.png';
                const standardLayer = L.tileLayer(tileBaseUrl + floor + '/{z}/{x}/{y}.png', {
                    attribution: '&copy; Jagex Ltd.', tms: false, noWrap: true, bounds: [[0, 0], [256, 256]], maxNativeZoom: maxNativeZoom
                });
                var sharpRetinaLayer = isRetina ? L.tileLayer(retinaUrl, {
                    attribution: '&copy; Jagex Ltd.', tms: false, noWrap: true, bounds: [[0, 0], [256, 256]], maxZoom: maxNativeZoom - 1
                }) : undefined;
                tileLayers[floor] = { standard: standardLayer, retina: sharpRetinaLayer };
            }

            map.on('zoomend', onZoomEnd);
            map.on('moveend', logMapState);
            map.setView([146.5088, 34.5174], 8);
            updateActiveLayers(); // Initial layer setup
            logMapState();
        }

        function onZoomEnd() {
            updateActiveLayers();
            updatePixelation();
        }

        function updatePixelation() {
            const container = tileLayers[currentFloor].standard.getContainer();
            if (container) {
                if (map.getZoom() >= maxNativeZoom) L.DomUtil.addClass(container, 'pixelated-zoom');
                else L.DomUtil.removeClass(container, 'pixelated-zoom');
            }
        }

        function updateActiveLayers() {
            const currentZoom = map.getZoom();

            for (let i = 0; i < numFloors; i++) {
                const layers = tileLayers[i];
                const targetOpacity = (i === currentFloor) ? 1.0 : (i === 0 && currentFloor > 0) ? 0.5 : 0.0;
                const shouldUseRetina = isRetina && layers.retina && currentZoom < maxNativeZoom;

                // Set opacity first
                layers.standard.setOpacity(targetOpacity);
                if (layers.retina) layers.retina.setOpacity(targetOpacity);
                
                // Add/remove standard layer
                if (!shouldUseRetina && targetOpacity > 0) {
                    if (!map.hasLayer(layers.standard)) map.addLayer(layers.standard);
                } else {
                    if (map.hasLayer(layers.standard)) map.removeLayer(layers.standard);
                }

                // Add/remove retina layer
                if (shouldUseRetina && targetOpacity > 0) {
                     if (!map.hasLayer(layers.retina)) map.addLayer(layers.retina);
                } else {
                    if (layers.retina && map.hasLayer(layers.retina)) map.removeLayer(layers.retina);
                }
            }
        }

        function setFloor(newFloor) {
            if (newFloor === currentFloor) return;
            
            if (poiLayers[currentFloor] && map.hasLayer(poiLayers[currentFloor])) {
                map.removeLayer(poiLayers[currentFloor]);
            }
            currentFloor = newFloor;
            if (poiLayers[currentFloor]) {
                map.addLayer(poiLayers[currentFloor]);
            }
            updateActiveLayers();
        }

        function loadPois(jsonData) {
            try {
                if (!map) return;
                const MIN_X_OFFSET = 1024, MAX_Y_OFFSET = 12608, PIXELS_PER_TILE = 4, conversionFactor = 256.0;
                const pois = JSON.parse(jsonData);

                for (let i = 0; i < numFloors; i++) poiLayers[i] = L.markerClusterGroup();

                pois.forEach(poi => {
                    if (poi.plane >= 0 && poi.plane < numFloors) {
                        let x_image = (poi.x - MIN_X_OFFSET) * PIXELS_PER_TILE + PIXELS_PER_TILE;
                        let y_image = (MAX_Y_OFFSET - poi.y) * PIXELS_PER_TILE - PIXELS_PER_TILE;
                        const marker = L.marker([y_image / conversionFactor, x_image / conversionFactor]);
                        marker.bindPopup(`<b>${poi.name}</b><br>Floor: ${poi.plane}<br>Game: [${poi.y}, ${poi.x}]`);
                        poiLayers[poi.plane].addLayer(marker);
                    }
                });
                if (poiLayers[currentFloor]) map.addLayer(poiLayers[currentFloor]);
            } catch(e) { console.error("ERROR in loadPois(): ", e); }
        }

        function logMapState() {
            const center = map.getCenter();
            const zoom = map.getZoom();
            console.log(`Map State - Floor: ${currentFloor}, Zoom: ${zoom}, Center: [${center.lat.toFixed(4)}, ${center.lng.toFixed(4)}]`);
        }
    </script>
</body>
</html>
