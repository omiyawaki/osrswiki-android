package com.omiyawaki.osrswiki.page

import android.content.Context
import android.util.Log
import android.webkit.WebResourceRequest
import android.webkit.WebResourceResponse
import com.omiyawaki.osrswiki.util.asset.AssetReader
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.json.JSONObject
import java.io.ByteArrayInputStream
import java.io.InputStream

/**
 * Universal CDN redirector that automatically redirects external JavaScript library requests 
 * to local assets based on automated CDN mapping generated by the tools/js network tracer.
 * 
 * This eliminates the need for hardcoded CDN rules by reading the automated mapping
 * from network trace results.
 */
class UniversalCdnRedirector(private val context: Context) {
    private val logTag = "UniversalCdnRedirector"
    private var cdnMapping: Map<String, Map<String, String>>? = null
    private var lastLoadAttempt = 0L
    private val reloadInterval = 30_000L // 30 seconds
    
    /**
     * Load CDN mapping from the latest network trace results.
     * This is called lazily and cached for performance.
     */
    private suspend fun loadCdnMapping(): Map<String, Map<String, String>> {
        val currentTime = System.currentTimeMillis()
        
        // Return cached mapping if available and recent
        if (cdnMapping != null && (currentTime - lastLoadAttempt) < reloadInterval) {
            return cdnMapping!!
        }
        
        lastLoadAttempt = currentTime
        
        return withContext(Dispatchers.IO) {
            try {
                // Try to read the network trace results (preferred source for CDN mapping)
                val networkTraceJson = AssetReader.readAssetFile(context, "network_trace.json")
                    ?: return@withContext emptyMap<String, Map<String, String>>()
                
                val jsonObject = JSONObject(networkTraceJson)
                
                // Check if this is a network trace report (has cdn_mapping)
                if (!jsonObject.has("cdn_mapping")) {
                    Log.w(logTag, "No cdn_mapping found in network_trace.json, falling back to empty mapping")
                    return@withContext emptyMap<String, Map<String, String>>()
                }
                
                val cdnMappingJson = jsonObject.getJSONObject("cdn_mapping")
                val mapping = mutableMapOf<String, Map<String, String>>()
                
                // Parse CDN mapping structure
                val hostKeys = cdnMappingJson.keys()
                while (hostKeys.hasNext()) {
                    val hostName = hostKeys.next()
                    val hostMappingJson = cdnMappingJson.getJSONObject(hostName)
                    val hostMapping = mutableMapOf<String, String>()
                    
                    val fileKeys = hostMappingJson.keys()
                    while (fileKeys.hasNext()) {
                        val fileName = fileKeys.next()
                        val localAssetPath = hostMappingJson.getString(fileName)
                        hostMapping[fileName] = localAssetPath
                    }
                    
                    if (hostMapping.isNotEmpty()) {
                        mapping[hostName] = hostMapping
                        Log.d(logTag, "Loaded CDN mapping for $hostName: ${hostMapping.size} files")
                    }
                }
                
                cdnMapping = mapping
                Log.i(logTag, "Loaded CDN mappings for ${mapping.size} hosts")
                mapping
                
            } catch (e: Exception) {
                Log.e(logTag, "Failed to load CDN mapping: ${e.message}", e)
                cdnMapping = emptyMap()
                emptyMap()
            }
        }
    }
    
    /**
     * Check if a request should be redirected to a local asset.
     * Returns the WebResourceResponse for the local asset if redirect applies, null otherwise.
     */
    suspend fun shouldRedirectRequest(request: WebResourceRequest): WebResourceResponse? {
        val url = request.url.toString()
        val host = request.url.host ?: return null
        val path = request.url.path ?: return null
        
        // Extract filename from path
        val filename = path.split("/").lastOrNull()?.split("?")?.firstOrNull()
        if (filename.isNullOrBlank()) {
            return null
        }
        
        // Load CDN mapping
        val mapping = loadCdnMapping()
        
        // Check if this host and file are in our CDN mapping
        val hostMapping = mapping[host] ?: return null
        val localAssetPath = hostMapping[filename] ?: return null
        
        try {
            // Load the local asset
            val assetStream = context.assets.open(localAssetPath)
            
            // Determine MIME type based on file extension
            val mimeType = when {
                filename.endsWith(".js") -> "application/javascript"
                filename.endsWith(".css") -> "text/css"
                filename.endsWith(".json") -> "application/json"
                else -> "application/octet-stream"
            }
            
            Log.i(logTag, "CDN REDIRECT: $url -> $localAssetPath")
            
            return WebResourceResponse(
                mimeType,
                "UTF-8",
                assetStream
            )
            
        } catch (e: Exception) {
            Log.w(logTag, "Failed to load local asset for CDN redirect: $localAssetPath - ${e.message}")
            return null
        }
    }
    
    /**
     * Get statistics about the loaded CDN mapping for debugging.
     */
    suspend fun getMappingStats(): String {
        val mapping = loadCdnMapping()
        val totalHosts = mapping.size
        val totalFiles = mapping.values.sumOf { it.size }
        
        val hostDetails = mapping.entries.take(5).joinToString(", ") { (host, files) ->
            "$host(${files.size})"
        }
        
        return "CDN Mapping: $totalHosts hosts, $totalFiles files. Examples: $hostDetails"
    }
    
    companion object {
        @Volatile
        private var instance: UniversalCdnRedirector? = null
        
        fun getInstance(context: Context): UniversalCdnRedirector {
            return instance ?: synchronized(this) {
                instance ?: UniversalCdnRedirector(context.applicationContext).also { instance = it }
            }
        }
    }
}